version 1.0;   /* XML version not script version */

/*
 * Copyright (c) 2014, Juniper Networks, Inc.
 * All rights reserved.
 * Filename      : event-accounting-options-rpc-mcast-routes.slax
 * Author        : Andre Stiphout <andre@juniper.net>
 * Platform      : MX TRIO
 * Release       : Junos 12.3+
 * Version       : 1.00
 * Date          : 2014-10-17 16:00
 * Description   : Obtain mcast route statistics and write into accounting-files
 *
 */

/*
 * The aim of the script is to retrieve those ifIndices of the interfaces that
 * require monitoring. The ifIndices are used to get various multicast route
 * and join statistics. The results are written directly into
 * accounting-files.
 *
 * No parameters will be passed to the script.
 * There are no version dependencies.
 *
 *  v0.90   Initial release.
 *  v0.91   Split a template into 2 templates to increase processing speed.
 *  v0.92   Added additional error reporting using syslog, added comments.
 *  v0.93   Added initial sleep to support staggered start.
 *  v0.94   Removed sleep.
 *  v0.95   Removed @junos:seconds from multicast-route-uptime.
 *  v0.96   Added+removed translation from space to underscore for multicast route uptime.
 *  v0.97   Added Routing-instance awareness in accounting-records and logging.
 *  v0.98   Added additional check to verify if the relevant routing-instance has been configured.
 *  v0.99   Removed translation from space to underscore for multicast route uptime.
 *  v1.00   Added ngtv_central routing-instance and renamed iptv_nextgen to ngtv_edge
 */

ns junos = "http://xml.juniper.net/junos/*/junos";
ns xnm = "http://xml.juniper.net/xnm/1.1/xnm";
ns jcs = "http://xml.juniper.net/junos/commit-scripts/1.0";
ns ext = "http://xmlsoft.org/XSLT/namespace";
 
import "../import/junos.xsl";

var $mgd = jcs:open();

match / {

    <event-script-results> {

        /* abort if no connection to local $mgd */
        if ($mgd/..//xnm:error) {
            call rpcFailure( $rpc = $mgd/.., $message = $script _ ": error connecting on mgd on this RE" );
            <xsl:message terminate="yes"> ;
        }

        /* check current RE is master RE. Stop execution if not */
        var $reStatus = { call checkMaster(); }

        if ($reStatus != "master") {
            expr jcs:syslog( "daemon.error", $script _ ": script not running on master RE. Stopping execution" );
            <xsl:message terminate="yes">;
        }

        /* MSTV: verify the instance is active on this router */
        var $getInstanceInfoMstv = <get-instance-information> {
            <instance-name> "iptv_dservers";
            <brief>;
        }
        var $instanceInfoMstv = jcs:execute( $mgd, $getInstanceInfoMstv );

        if ( $instanceInfoMstv/..//xnm:error ) {
            call rpcFailure( $rpc = $instanceInfoMstv/.., $message = $script _ ": error on show route instance brief: iptv_dservers" );

        } else if ( not( jcs:empty ( $instanceInfoMstv/instance-core/instance-name ))) {

            /* create rpc and add accounting-records for Multicast summary stats */
            call createRpcMcastSummary( $instance = "iptv_dservers" );

            /* create rpc and add accounting-records for Multicast route stats */
            call createRpcMcastRoutes( $instance = "iptv_dservers" );

            /* create rpc and add accounting-records for Multicast usage stats */
            call createRpcMcastUsage( $instance = "iptv_dservers" );

       }

        /* NGTV-edge: verify the instance is active on this router */
        var $getInstanceInfoNgtvEdge = <get-instance-information> {
            <instance-name> "ngtv_edge";
            <brief>;
        }
        var $instanceInfoNgtvEdge = jcs:execute( $mgd, $getInstanceInfoNgtvEdge );

        if ( $instanceInfoNgtvEdge/..//xnm:error ) {
            call rpcFailure( $rpc = $instanceInfoNgtvEdge/.., $message = $script _ ": error on show route instance brief: ngtv_edge" );

        } else if ( not( jcs:empty ( $instanceInfoNgtvEdge/instance-core/instance-name ))) {

            /* create rpc and add accounting-records for Multicast summary stats */
            call createRpcMcastSummary( $instance = "ngtv_edge" );

            /* create rpc and add accounting-records for Multicast route stats */
            call createRpcMcastRoutes( $instance = "ngtv_edge" );

            /* create rpc and add accounting-records for Multicast usage stats */
            call createRpcMcastUsage( $instance = "ngtv_edge" );

       }

        /* NGTV-central: verify the instance is active on this router */
        var $getInstanceInfoNgtvCentral = <get-instance-information> {
            <instance-name> "ngtv_central";
            <brief>;
        }
        var $instanceInfoNgtvCentral = jcs:execute( $mgd, $getInstanceInfoNgtvCentral );

        if ( $instanceInfoNgtvCentral/..//xnm:error ) {
            call rpcFailure( $rpc = $instanceInfoNgtvCentral/.., $message = $script _ ": error on show route instance brief: ngtv_central" );

        } else if ( not( jcs:empty ( $instanceInfoNgtvCentral/instance-core/instance-name ))) {

            /* create rpc and add accounting-records for Multicast summary stats */
            call createRpcMcastSummary( $instance = "ngtv_central" );

            /* create rpc and add accounting-records for Multicast route stats */
            call createRpcMcastRoutes( $instance = "ngtv_central" );

            /* create rpc and add accounting-records for Multicast usage stats */
            call createRpcMcastUsage( $instance = "ngtv_central" );

       }

    }

    /* closes the connection handle */
    expr jcs:close( $mgd );
}

template createRpcMcastSummary( $instance ) {

    /* error if no instance provided */
    if (jcs:empty( $instance )) {
        expr jcs:syslog( "daemon.error", $script _ ": no instance passed to createRpcMcastSummary()" );
    }

    /* retrieve multicast route summary for instance  */
    var $getMcastRouteSummary = <get-multicast-route-information> {
        <instance> $instance;
        <active>;
        <summary>;
        <inet>;
    }
    var $mcastRouteSummary = jcs:execute( $mgd, $getMcastRouteSummary );

    if ( $mcastRouteSummary/..//xnm:error ) {
        call rpcFailure( $rpc = $mcastRouteSummary/.., $message = $script _ ": error on show mcast route summary for instance: " _ $instance );
    }

    mvar $mcastRouteCount = $mcastRouteSummary/route-family/multicast-route/multicast-route-summary/multicast-route-count;
    if ( jcs:empty( $mcastRouteCount )) {
        set $mcastRouteCount = "0";
    }

    /* retrieve pim join summary for instance  */
    var $getPimJoinSummary = <get-pim-join-information> {
        <instance> $instance;
        <summary>;
        <inet>;
    }
    var $pimJoinSummary = jcs:execute( $mgd, $getPimJoinSummary );

    if ( $pimJoinSummary/..//xnm:error ) {
        call rpcFailure( $rpc = $pimJoinSummary/.., $message = $script _ ": error on show pim join summary for instance: " _ $instance );
    }

    /* invalid xml PR/974943, temporary solution follows: */
    mvar $pimSourceGroupRouteCount = $pimJoinSummary/join-family/join-summary/multicast-route-count;
    if ( jcs:empty( $pimSourceGroupRouteCount )) {
        set $pimSourceGroupRouteCount = "0";
    }

    mvar $pimStarGroupRouteCount = $pimJoinSummary/join-family/join-summary/multicast-route-count/following::multicast-route-count;
    if ( jcs:empty( $pimStarGroupRouteCount )) {
        set $pimStarGroupRouteCount = "0";
    }

    /* once PR/974943 is fixed, probable solution follows, needs to updated to mvar: 
    var $pimSourceGroupRouteCount = $pimJoinSummary/join-family/join-summary[ multicast-route-type == "(s,g)"]/following::multicast-route-count;
    var $pimStarGroupRouteCount = $pimJoinSummary/join-family/join-summary[ multicast-route-type == "(*,g)"]/following::multicast-route-count;    
     */

    /* assume there will be no failure on the RPC call */
    mvar $rpcSuccess = true();

    /* create accounting-record for mcast join statistics */
    var $addAccountingRecord = <add-accounting-file-record> {
        <file> "rpcStatMcastJoins";
        <layout> "rpcMcastJoins";
        <fields> "instanceName,ipMRouteEntryCount,pimSourceGroupRouteCount,pimStarGroupRouteCount";
        <data> 
            $instance _ "," _
            $mcastRouteCount _ "," _
            $pimSourceGroupRouteCount _ "," _
            $pimStarGroupRouteCount;
    }
    var $accountingRecord = jcs:execute( $mgd, $addAccountingRecord );

    if ( $accountingRecord/..//xnm:error ) {

        call rpcFailure( $rpc = $accountingRecord/.., $message = $script _ ": error adding accounting record to file rpcStatMcastJoins" );

        expr jcs:syslog( "daemon.notice", $script _ ": " _ $addAccountingRecord );

        /* record there is a failure on the RPC call */
        set $rpcSuccess = false();
    }

    /* all being well log successful run of script */
    if ( $rpcSuccess ) {
        expr jcs:syslog( "daemon.notice", $script _ ": multicast summary statistics for " _ $instance _ " using RPC updated successfully" );
    } else {
        expr jcs:syslog( "daemon.notice", $script _ ": multicast summary statistics for " _ $instance _ " using RPC not updated successfully" );
    }
}

template createRpcMcastRoutes( $instance ) {

    /* error if no instance provided */
    if (jcs:empty( $instance )) {
        expr jcs:syslog( "daemon.error", $script _ ": no instance passed to createRpcMcastRoutes()" );
    }

    /* retrieve multicast route for instance  */
    var $getMcastRoutes = <get-multicast-route-information> {
        <instance> $instance;
        <active>;
        <extensive>;
        <inet>;
    }
    var $mcastRoutes = jcs:execute( $mgd, $getMcastRoutes );

    if ( $mcastRoutes/..//xnm:error ) {
        call rpcFailure( $rpc = $mcastRoutes/.., $message = $script _ ": error on show mcast route extensive" );
    }

    /* assume there will be no failure on the RPC call */
    mvar $rpcSuccess = true();

    /* for all (S,G) that we previously retrieved */
    for-each ( $mcastRoutes/route-family/multicast-route ) {

        /* create accounting-record for mcast route statistics */
        var $addAccountingRecord = <add-accounting-file-record> {
            <file> "rpcStatMcastRoutes";
            <layout> "rpcMcastRoutes";
            <fields> "instanceName,ipMRouteGroup,ipMRouteSource,ipMRouteSourceMask,ipMRouteUpTime,ipMRouteDifferentInIfPackets";
            <data> 
                $instance _ "," _
                multicast-group-address _ "," _
                multicast-source-address _ "," _
                multicast-source-prefix-length _ "," _
                multicast-route-uptime _ "," _
                interface-mismatch-count;
        }
        var $accountingRecord = jcs:execute( $mgd, $addAccountingRecord );

        if ( $accountingRecord/..//xnm:error ) {

            call rpcFailure( $rpc = $accountingRecord/.., $message = $script _ ": error adding accounting record to file rpcStatMcastRoutes" );

            expr jcs:syslog( "daemon.notice", $script _ ": " _ $addAccountingRecord );

            /* record there is a failure on the RPC call */
            set $rpcSuccess = false();
        }
    }

    /* all being well log successful run of script */
    if ( $rpcSuccess ) {
        expr jcs:syslog( "daemon.notice", $script _ ": multicast route statistics for " _ $instance _ " using RPC updated successfully" );
    } else {
        expr jcs:syslog( "daemon.notice", $script _ ": multicast route statistics for " _ $instance _ " using RPC not updated successfully" );
    }
}

template createRpcMcastUsage( $instance ) {

    /* error if no instance provided */
    if (jcs:empty( $instance )) {
        expr jcs:syslog( "daemon.error", $script _ ": no instance passed to createRpcMcastUsage()" );
    }

    /* retrieve multicast usage for instance  */
    var $getMcastUsage = <get-multicast-usage-information> {
        <instance> $instance;
        <detail>;
        <inet>;
    }
    var $mcastUsage = jcs:execute( $mgd, $getMcastUsage );

    if ( $mcastUsage/..//xnm:error ) {
        call rpcFailure( $rpc = $mcastUsage/.., $message = $script _ ": error on show mcast usage detail" );
    }

    /* assume there will be no failure on the RPC call */
    mvar $rpcSuccess = true();

    /* for all (S,G) that we previously retrieved */
    for-each ( $mcastUsage/multicast-group/multicast-group-source ) {

        /* create accounting-record for mcast usage statistics */
        var $addAccountingRecord = <add-accounting-file-record> {
            <file> "rpcStatMcastUsage";
            <layout> "rpcMcastUsage";
            <fields> "instanceName,ipMRouteGroup,ipMRouteSource,ipMRouteSourceMask,ipMRouteHCOctets";
            <data> 
                $instance _ "," _
                ancestor::multicast-group/multicast-group-address _ "," _
                multicast-source-address _ "," _
                multicast-source-prefix-length _ "," _
                multicast-byte-count;
        }
        var $accountingRecord = jcs:execute( $mgd, $addAccountingRecord );

        if ( $accountingRecord/..//xnm:error ) {

            call rpcFailure( $rpc = $accountingRecord/.., $message = $script _ ": error adding accounting record to file rpcStatMcastUsage" );

            expr jcs:syslog( "daemon.notice", $script _ ": " _ $addAccountingRecord );

            /* record there is a failure on the RPC call */
            set $rpcSuccess = false();
        }
    }

    /* all being well log successful run of script */
    if ( $rpcSuccess ) {
        expr jcs:syslog( "daemon.notice", $script _ ": multicast usage statistics for " _ $instance _ " using RPC updated successfully" );
    } else {
        expr jcs:syslog( "daemon.notice", $script _ ": multicast usage statistics for " _ $instance _ " using RPC not updated successfully" );
    }
}

template checkMaster() {

    /* master-state is available natively when querying junos-context */
    if ( $junos-context ) {
        if ( $junos-context/re-master ) {
          <output> "master";
        }
        else {
           <output> "backup";
        }
    }
    /* if not available, other means are used to determine mastership */
    else {

        var $getReInfo = <get-route-engine-information> ;
        var $reInfo = jcs:execute( $mgd, $getReInfo );

        if ( $reInfo/..//xnm:error ) {
            call rpcFailure( $rpc = $reInfo/.., $message = $script _ ": error communicating to determine if master" );
            <xsl:message terminate="yes"> ;
        }

        /* if there is only one RE then is has to be master */
        if ( $reInfo/route-engine ) {
            if ( count( $reInfo/route-engine ) == 1 ) {
                <output> "master";
            } else {

                /* this command only works on master RE with MX chassis */
                var $getChassisInfo = <get-chassis-inventory> ;
                var $chassisInfo = jcs:execute( $mgd, $getChassisInfo );

                if ($chassisInfo/..//xnm:error) { 
                    call rpcFailure( $rpc = $reInfo/.., $message = $script _ ": error getting Chassis information." );
                    <xsl:message terminate="yes"> ;
                }

                if ( $chassisInfo/chassis/serial-number ) {
                    <output> "master";
                } else {
                    <output> "backup";
                }
            }
        } else {
            expr jcs:syslog( "daemon.error", $script _ ": ERROR, Unexpected response: " _ $reInfo );
            <xsl:message terminate="yes">;
        }
    }
}

template rpcFailure( $rpc, $message = "Following errors occured while trying to gather data: " ) {

    expr jcs:syslog( "daemon.error", $message );

    for-each ( $rpc//xnm:error ) {
        expr jcs:syslog( "daemon.error", message );
    }
}
