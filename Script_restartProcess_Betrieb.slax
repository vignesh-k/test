/* 
	Script to simulate the "restart <protocol> [|gracefully|soft|immediately]" CLI command.
		restart <protocol> [|gracefully|soft|immediately]
*/

/*
	Author: bcersows
	Version: 1.01d
	Date: 23.04.2014
	Last Modified By: bcersows
	###Script_restartProcess_Betrieb.slax;v1.01c;2014.04.23
*/

version 1.1;

ns junos = "http://xml.juniper.net/junos/*/junos";
ns xnm = "http://xml.juniper.net/xnm/1.1/xnm";
ns jcs = "http://xml.juniper.net/junos/commit-scripts/1.0";
/*ns slax = "http://xml.libslax.org/slax";*/
ns date = "http://exslt.org/dates-and-times";
ns str = "http://exslt.org/strings";

ns bcersows = "http://bcersows@telekom.de";
import "Space_Library-Local.slax";

import "../import/junos.xsl";

/* @CONTEXT = "/device" */
/* @NAME = "NE - Restart Protocol" */
/* @DESCRIPTION = "Restarts a protocol process." */
/* @ISLOCAL = "true" */
/* @EXECUTIONTYPE = "GROUPEDEXECUTION" */
/* @VARIABLECONTEXT = "[{'name':'processName','selectionvalues':',dhcp-service,dynamic-flow-capture,extensible-subscriber-services,firewall,snmp'},{'name':'option','selectionvalues':',gracefully,soft,immediately'}]" */
/* @PASSDEVICECREDENTIALS = "true" */

mvar $counter = 0;

var $arguments = {
	<argument> {
		<name> "CONTEXT";
		<description> "Context beim Aufruf.";
	}
	<argument> {
		<name> "processName";
		<description> "Name of the protocol to restart. <br />Some already available via list. If not, enter the right process name.";
	}
	<argument> {
		<name> "option";
		<description> "Further options for restarting.";
	}
}
param $CONTEXT;
param $processName;
param $option;

match / {
<op-script-results> {
/*template junoscript() {*/
	mvar $results;
	
	mvar $localtime = date:date-time();
	
	/*
	*	Get configuration.
	*/
	
	mvar $hostname;       /* credentials of user@ip           */
	mvar $splitHostname;  /* array of user and ip credentials */
	mvar $ip;             /* credentials ip address           */
	mvar $user;           /* credentials username             */
	mvar $password;       /* credentials password             */
	
	/* Split interfaces and Credentials */
	var $devices = jcs:split("\\|", $CONTEXT);
	var $splitCredentials = str:split( $credentials , "\\;" );
	
	/* Push the devices and according credentials into one node-set. */
	var $deviceCredentials := {
		for-each ( $devices ) {
			var $position = position();
			<device> {
				<name> .;
				<credentials> $splitCredentials[ $position ];
			}
		}
	}
	
	var $myDevice = {
		for-each ( $deviceCredentials/device/name ) {
			<xsl:sort>;
			expr jcs:regex( "/device\\[name=\"([^\"]*)\"\\].*", . )[2];
			if ( position() != last() ) {
				expr ", ";
			}
		}
	}
	
	var $rpc = { <command> {
			expr "restart " _ $processName;
			if ( $option ) {
				expr " " _ $option;
			} 
		}
	}
	
	<output> {
		<HTML> {
			<HEAD> {
				<title> "Informationen ueber BNG " _ $myDevice _ ".";
				copy-of bcersows:insertCSS();
				copy-of bcersows:insertJS();
			}
			<BODY> {

				copy-of bcersows:insertHeaderBig( $myDevice );
				/*copy-of bcersows:insertCurrentTime();*/
				
				copy-of bcersows:insertCompletionTest();
				
				/*if ( $connection ) { } else {	
					<div class="error"> {
						expr "Konnte keine Verbindung aufbauen."; <br>;
						expr "Abbruch folgt.";
					}
				}*/
				
				/*copy-of bcersows:insertSoftwareInformation( $connection );*/
				
				<p class="bold subheader">{
					<span class="left"> { expr "Restart Output(s)"; }
					copy-of bcersows:insertDownloadButton( "resultsTable", "restartOutput" );
				}
				
				/* Table to have something to export. */
				<table id="resultsTable" style="display: none;"> {
					<tr> {
						<td> "Device";
						<td> "Result";
					}
					for-each ( $deviceCredentials/device ) {
						<xsl:sort>;
						/* Using the count of unique devices found, the correct connection */
						/* parameters to be used can be derived from $splitCredentials     */
						var $splitCredential = str:split( ./credentials, "\\:" );
						
						set $hostname = $splitCredential[1];
						set $password = $splitCredential[2];
						set $splitHostname = str:split( $hostname[1] , "\@");
						set $user = $splitHostname[1];
						set $ip = $splitHostname[2];
						var $dev = jcs:regex( "/device\\[name=\"([^\"]*)\"\\].*", ./name )[2];
						
						var $connection = jcs:open( $ip , $user , $password );
						
						<tr> {
							<td> $dev;
							if ( $connection && !$connection//self::xnm:error ) {
								set $results = jcs:execute( $connection, $rpc );
								
								<div> {
									<p class="bold subheader">{
										<span class="left lpadding5"> { expr "Restart Output for " _ $dev; }
									}
									call checkErrors( $resultsNodeSet = $results, $connection, $msg = "Error." );
									<p> {
										expr "Issued command was \"";
										<span class="italic"> { expr $rpc; } 
										expr "\".";
									}
									<p class="italic"> {
										expr $results;
									}					
									copy-of bcersows:insertBackButton();
								}
								<td> $results;
							} else {
								<div class="error"> {
									<span class="bold"> { expr "Error with " _ $dev _ ":"; } <br>;
									if ( $connection ) {
										for-each ( $connection//self::xnm:error ) {
											expr .; <br>;
										}
									}
								}
								<td> "Could not open connection.";
							}
						
						}
					}
				}
				var $duration = date:seconds() - date:seconds( $localtime );
				<div class="wholeLine"> {
				<span class="left italic unselectable"> "vs. 1.01c";
					expr "Dauer der Ausf"; <xsl:text disable-output-escaping="yes"> "&uuml;"; expr "hrung: " _ $duration _ "s. ";
				}
			}
		}
	}

	set $unlock-results = jcs:execute( $connection, "unlock-database" );
	expr jcs:close( $connection );
	
}
}

template checkErrors ( $resultsNodeSet, $msg = "", $connection ) {
	if( $resultsNodeSet//self::xnm:error ) {
		copy-of bcersows:outputErrorDiv($resultsNodeSet, $msg);
	}
}
